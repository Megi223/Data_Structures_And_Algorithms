#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <climits>
#include <unordered_map>
#include <queue>
#include <set>

using namespace std;


// type -> 0 - auto
//      -> 1 - rail
struct Edge {
    size_t id;
    size_t to;
    size_t weight;
    bool type;
    Edge(size_t _to, size_t _weight, bool _type) : to(_to), weight(_weight), type(_type) {

    }


};

size_t N;
//set<Edge> edges;
unordered_map<size_t, vector<Edge>> graph;
unordered_map<size_t, size_t> distances;
size_t cnt = 0;
unordered_map<size_t, bool> railEdges;
unordered_map<size_t, size_t> railEdgesCnt;
set<pair<size_t, size_t>> repeated;
vector<Edge> vectEdges;
unordered_map<size_t, size_t> vertices;
struct Comparator {
    bool operator()(pair<size_t, Edge> f, pair<size_t, Edge> s) {
        if (f.first == s.first) {
            if (f.second.type == s.second.type) {
                return f.second.weight > s.second.weight;
            }
            return f.second.type > s.second.type;
        }
        return f.first > s.first;
    }
};
void dijkstra(size_t start) {
    for (size_t i = 1; i <= N; i++) {
        distances[i] = LONG_MAX;
    }
    distances[start] = 0;
    priority_queue<pair<size_t, Edge>, vector<pair<size_t, Edge>>, Comparator> pq;
    pq.push({ 0,Edge(start,0,0) });
    while (!pq.empty()) {
        if (pq.top().first != distances[pq.top().second.to]) { pq.pop(); continue; }
        size_t current = pq.top().second.to;
        pq.pop();

        for (auto n : graph[current]) {
            if (distances[n.to] > distances[current] + n.weight) {
                distances[n.to] = distances[current] + n.weight;
                pq.push({ distances[n.to],n });
                // it is used- cant be removed
                if (n.type) {
                    cnt+= railEdgesCnt[n.id];
                    railEdges[n.id] = false;
                    //vertices.insert({ n.to,n.id });
                    vertices[n.to] = n.id;
                    //cout << n.id;
                }
            }
            else if (distances[n.to] == distances[current] + n.weight && vertices.find(n.to) != vertices.end()) {
                cnt-= railEdgesCnt[vertices[n.to]];
                vertices.erase(n.to);
                //railEdges[]
            }
        }
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    size_t M, K, from, to, weight;
    cin >> N >> M >> K;
    for (size_t i = 0; i < M; i++) {
        cin >> from >> to >> weight;
        Edge e(to, weight, 0);
        Edge sec(from, weight, 0);
        graph[from].push_back(e);
        graph[to].push_back(sec);
    }
    for (size_t i = 0; i < K; i++) {
        cin >> to >> weight;
        Edge rail(to, weight, 1);
        rail.id = i;
        vectEdges.push_back(rail);
        for (size_t y = 0; y < vectEdges.size(); y++) {
            if (vectEdges[y].to == to && vectEdges[y].weight == weight) {
                rail.id = vectEdges[y].id;
                break;
            }
        }
        /*if (repeated.find({to,weight}) == repeated.end()) {
            repeated.insert(to, weight);
            rail.id = i;


        }
        else {

        }*/
        if (rail.id == i) {
            graph[1].push_back(rail);

        }
        railEdges[rail.id] = true;
        railEdgesCnt[rail.id]++;
    }
    dijkstra(1);
    size_t removedCnt = 0;
    for (auto iter = railEdges.begin(); iter != railEdges.end(); iter++) {
        if (iter->second) {
            removedCnt += railEdgesCnt[iter->first];
        }
    }
    //cout << railEdgesCnt.size();
    //cout << removedCnt;
    cout << K - cnt;
}












#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <climits>
#include <unordered_map>
#include <queue>

using namespace std;


// type -> 0 - auto
//      -> 1 - rail
struct Edge {
    size_t to;
    size_t weight;
    bool type;
    Edge(size_t _to, size_t _weight, bool _type) : to(_to), weight(_weight), type(_type) {

    }
    

};

size_t N;
//set<Edge> edges;
unordered_map<size_t, vector<Edge>> graph;
unordered_map<size_t, size_t> distances;
size_t cnt = 0;
struct Comparator {
    bool operator()(pair<size_t, Edge> f, pair<size_t, Edge> s) {
        if (f.first == s.first) {
            if (f.second.type == s.second.type) {
                return f.second.weight > s.second.weight;
            }
            return f.second.type > s.second.type;
        }
        return f.first > s.first;
    }
};
void dijkstra(size_t start) {
    for (size_t i = 1; i <= N; i++) {
        distances[i] = LONG_MAX;
    }
    distances[start] = 0;
    priority_queue<pair<size_t, Edge>, vector<pair<size_t, Edge>>, Comparator> pq;
    pq.push({ 0,Edge(start,0,0) });
    while (!pq.empty()) {
        if (pq.top().first != distances[pq.top().second.to]) { pq.pop(); continue; }
        size_t current = pq.top().second.to;
        pq.pop();

        for (auto n : graph[current]) {
            if (distances[n.to] > distances[current] + n.weight) {
                distances[n.to] = distances[current] + n.weight;
                pq.push({ distances[n.to],n });
                if (n.type) {
                    cnt++;
                }
            }
        }
    }
}

int main() {

    size_t M, K, from, to, weight;
    cin >> N >> M >> K;
    for (size_t i = 0; i < M; i++) {
        cin >> from >> to >> weight;
        Edge e(to, weight, 0);
        Edge sec(from, weight, 0);
        graph[from].push_back(e);
        graph[to].push_back(sec);
    }
    for (size_t i = 0; i < K; i++) {
        cin >> to >> weight;
        Edge rail(to, weight, 1);
        graph[1].push_back(rail);
    }
    dijkstra(1);
    cout << K - cnt;
}
